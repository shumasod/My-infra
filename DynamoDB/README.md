# DynamoDBテーブル設計とクエリパターン解説

このドキュメントでは、注文管理システムを例に、DynamoDBのテーブル設計とクエリパターンについて解説します。各項目には、その役割や設計時の注意点、実装の際のポイントなどを補足しています。

---

## 1. テーブル基本設計

テーブル設計の基本となる部分です。注文管理システムのユースケースに合わせたキー設計やインデックス設定の基本構造を示します。

### 1.1 キー スキーマ

```javascript
{
  TableName: 'Orders',
  KeySchema: [
    { AttributeName: 'PK', KeyType: 'HASH' },  // パーティションキー
    { AttributeName: 'SK', KeyType: 'RANGE' }  // ソートキー
  ]
}
```

**補足説明：**
- **パーティションキー (PK)：**  
  データの分散や検索効率を決定する主要な識別子です。この例では、ユーザーごとにデータをまとめるために使用されます。
- **ソートキー (SK)：**  
  同じパーティション内でデータを時系列やその他の順序付け基準で整理するために利用します。ここでは注文日など、順序が重要な情報を扱うのに適しています。

### 1.2 インデックス設定

基本のテーブルに加え、効率的な検索や柔軟なクエリのためにインデックスを設計します。

* **プライマリインデックス：**
  - **PK (パーティションキー):** ユーザーID  
    ユーザーごとの注文情報のグループ化に使用。
  - **SK (ソートキー):** 注文日  
    注文日を基準に並べ替え、履歴の取得や期間指定検索を容易にします。

* **グローバルセカンダリインデックス (GSI1)：**
  - **GSI1PK:** 注文ステータス  
    注文の状態（例：COMPLETED, PENDINGなど）に基づく検索が可能となります。
  - **GSI1SK:** 注文日  
    ステータスごとの注文を、日付でソートすることで、期間指定のクエリにも対応できます。

**補足説明：**
- **インデックスの利点：**  
  インデックスを追加することで、主テーブルの設計に影響を与えずに多様な検索パターンを実現できます。特にアクセス頻度の高いクエリ（例：注文ステータス別の検索など）に対して、専用のインデックスを設けるとパフォーマンスが向上します。

### 1.3 アクセスパターン分析プロセス

DynamoDBテーブル設計において最も重要なのは、アクセスパターンの理解とそれに基づいた設計です。以下の手順でアクセスパターンを分析します：

1. **ビジネス要件の明確化**  
   - 「ユーザーは自分の注文履歴を日付順に表示できる」
   - 「管理者は特定のステータスの注文を一覧表示できる」
   - 「特定期間の注文集計が必要」など

2. **アクセスパターンの抽出**  
   各要件から必要なデータアクセスパターンを特定します：
   - ユーザーIDによる注文履歴検索（日付降順）
   - 注文ステータス別の検索
   - 日付範囲による検索

3. **頻度と重要度の評価**  
   各アクセスパターンの使用頻度と重要度を評価し、優先順位を決定します：
   - 高頻度・高重要度：ユーザーの注文履歴検索（メインのユースケース）
   - 中頻度・高重要度：ステータス別注文検索（運用管理）
   - 低頻度・中重要度：期間別集計（レポート作成）

4. **キー設計への反映**  
   優先度の高いアクセスパターンをプライマリインデックスで、その他のパターンをGSIでサポートします。

---

## 2. データモデリング例

実際の注文アイテムのデータ構造例を示し、どのような属性を持たせるかを具体的に解説します。

### 2.1 注文アイテムの構造

```javascript
{
  PK: 'USER#123',           // ユーザーID
  SK: 'ORDER#2024-01-01',    // 注文日
  orderId: 'ORD-001',        // 注文固有ID
  userId: '123',             // ユーザーID（冗長性のために保持する場合も）
  orderDate: '2024-01-01',   // 注文日（検索・表示用）
  status: 'COMPLETED',       // 注文状態（例：COMPLETED, PENDINGなど）
  total: 5000,               // 注文合計金額
  items: [
    { productId: 'P1', quantity: 2, price: 1500 },
    { productId: 'P2', quantity: 1, price: 2000 }
  ],
  GSI1PK: 'ORDER#COMPLETED', // GSI用：注文状態を含むキー
  GSI1SK: '2024-01-01',      // GSI用：注文日（ソート用）
  expirationTime: 1735689600 // TTL: 2025-01-01 00:00:00（Unix時間）
}
```

**補足説明：**
- **冗長性:**  
  主テーブルのキーと別に、検索に必要な属性（例：orderDateやstatus）を各項目としても保持することで、効率的なクエリが可能です。
- **items配列:**  
  複数の注文アイテムを含む場合は、ネストされたデータ構造を利用し、商品の詳細（productId、数量、単価）をまとめています。
- **expirationTime属性:**  
  TTL（Time To Live）機能のための属性。Unix時間形式で指定した時刻を過ぎると、DynamoDBが自動的にアイテムを削除します。

---

## 3. 主要クエリパターン

具体的なクエリ例を示し、どのようにデータを取得するかを説明します。

### 3.1 ユーザーの注文履歴取得

```javascript
{
  TableName: 'Orders',
  KeyConditionExpression: 'PK = :userId',
  ExpressionAttributeValues: {
    ':userId': 'USER#123'
  },
  ScanIndexForward: false, // 降順に取得（最新の注文から表示）
  ProjectionExpression: 'orderId, orderDate, status, total' // 必要な属性のみ取得
}
```

**補足説明：**
- **ポイント:**  
  ユーザーIDをパーティションキーに設定することで、該当ユーザーのすべての注文履歴を一度に取得できます。
- **ScanIndexForward:**  
  falseに設定することで、最新の注文から表示するよう降順にソートします。
- **ProjectionExpression:**  
  必要な属性のみを取得することで、データ転送量を削減し、コストとパフォーマンスを最適化します。

### 3.2 期間指定での注文取得

```javascript
{
  TableName: 'Orders',
  KeyConditionExpression: 'PK = :userId AND SK BETWEEN :startDate AND :endDate',
  ExpressionAttributeValues: {
    ':userId': 'USER#123',
    ':startDate': 'ORDER#2024-01-01',
    ':endDate': 'ORDER#2024-12-31'
  }
}
```

**補足説明：**
- **期間指定検索:**  
  ソートキーを使い、特定期間内の注文情報を絞り込むためのクエリです。BETWEEN句を用いることで、開始日から終了日までの範囲検索を実現しています。

### 3.3 ステータス別注文取得（GSI使用）

```javascript
{
  TableName: 'Orders',
  IndexName: 'GSI1',
  KeyConditionExpression: 'GSI1PK = :status',
  ExpressionAttributeValues: {
    ':status': 'ORDER#COMPLETED'
  }
}
```

**補足説明：**
- **GSIの利用:**  
  プライマリキー以外の属性（この場合は注文状態）での検索が可能です。GSI1PKに基づいて、特定のステータスの注文情報を効率的に取得できます。

### 3.4 トランザクション処理による複数アイテムの一貫した更新

```javascript
{
  TransactItems: [
    {
      Update: {
        TableName: 'Orders',
        Key: { PK: 'USER#123', SK: 'ORDER#2024-01-01' },
        UpdateExpression: 'SET status = :newStatus, updatedAt = :now',
        ExpressionAttributeValues: {
          ':newStatus': 'SHIPPED',
          ':now': '2024-01-02T10:30:00Z'
        }
      }
    },
    {
      Update: {
        TableName: 'Inventory',
        Key: { productId: 'P1' },
        UpdateExpression: 'SET stock = stock - :quantity',
        ExpressionAttributeValues: {
          ':quantity': 2
        }
      }
    }
  ]
}
```

**補足説明：**
- **トランザクション処理:**  
  注文ステータスの更新と在庫の減少を単一のトランザクションとして処理することで、データの一貫性を保証します。
- **全体の成功または失敗:**  
  TransactWriteItemsは、すべての操作が成功するか、すべての操作が失敗するかのいずれかとなり、データの整合性を確保します。

---

## 4. 設計のベストプラクティス

システム全体のパフォーマンスや拡張性を高めるための設計上の注意点や推奨事項です。

### 4.1 キー設計のポイント
* **主要識別子:**  
  パーティションキーにはデータの一意性を担保する主要な識別子を使用します。ユーザーIDや注文IDなどが適しています。
* **ソートキー:**  
  時系列データや範囲検索が必要な属性を設定することで、後続のクエリパフォーマンスが向上します。
* **GSI:**  
  頻繁な検索パターンに合わせ、必要な属性に対してグローバルセカンダリインデックスを設計します。

### 4.2 データモデリングの注意点
* **単一テーブルデザイン:**  
  関連するデータを1つのテーブルに格納することで、JOIN処理を回避し、パフォーマンスの最適化を図ります。
* **事前の検索パターン定義:**  
  どのようなクエリが頻繁に行われるかを前もって把握し、それに合わせた属性やインデックスの設計を行います。
* **明確な命名規則:**  
  属性名やインデックス名は、誰が見ても理解しやすいように一貫した命名規則を採用することが重要です。

### 4.3 大規模データ対応の戦略
* **パーティション分散の最適化:**  
  - パーティションキーにランダムサフィックスを追加し、データをより均等に分散
  ```javascript
  // ユーザー別アクセスが非常に多い場合
  PK: 'USER#123#01', // 01~10のサフィックスを追加してデータを分散
  ```
  
* **複合キーの活用:**  
  - 複雑な検索条件をサポートするため、複数の属性を組み合わせたキーの構築
  ```javascript
  // 地域別かつステータス別の検索
  GSI2PK: 'REGION#TOKYO#STATUS#PENDING'
  ```

* **スパースインデックスの利用:**  
  - 特定の条件を満たすアイテムのみにGSI属性を設定し、インデックスサイズを最適化

---

## 5. 拡張検討ポイント

将来的な要件追加やシステム拡張を見据えた設計上の検討事項です。

### 5.1 追加可能な機能
* **製品カテゴリによる検索:**  
  新しいGSIを追加し、製品カテゴリをキーにした検索を可能にすることで、ユーザー体験を向上できます。
* **注文金額による範囲検索:**  
  注文合計金額を元にしたフィルタリング機能を追加することで、金額に応じたデータ抽出が可能になります。
* **配送ステータスの追跡:**  
  注文の配送状況を管理するフィールドを追加するなど、サービス向上のための拡張を検討します。

### 5.2 パフォーマンス最適化
* **ホットパーティションの回避:**  
  特定のパーティションにアクセスが集中しないよう、キー設計やデータ分散に注意する必要があります。
* **バッチ処理:**  
  一括更新や集計処理は、バッチ処理を活用して効率的に実施します。
* **スキャンオペレーションの最小化:**  
  クエリやインデックスを適切に設定し、必要最小限のデータ取得に留めることで、コストとパフォーマンスのバランスを図ります。

### 5.3 データライフサイクル管理
* **TTLの活用:**  
  古いデータを自動的に削除するためにTTL属性を設定し、ストレージコストを削減します。
  ```javascript
  {
    // 注文データ属性
    expirationTime: 1735689600 // 2025-01-01 00:00:00（Unix時間）
  }
  ```

* **アーカイブ戦略:**  
  TTLで削除される前に、履歴データをS3に保存し、AWS Athenaなどでの分析に活用する戦略を構築します。
  ```javascript
  // DynamoDB Streams + Lambda + S3 連携
  // 1. アイテムが削除される前にDynamoDB Streamsで変更を検知
  // 2. Lambdaでデータを処理しS3に保存
  // 3. S3に保存されたデータをAthenaで分析
  ```

---

## 6. 実装時の注意点

実際にシステムを実装する際のエラーハンドリングやコスト最適化のポイントを解説します。

### 6.1 エラーハンドリング

```javascript
try {
  const result = await dynamodb.query(params).promise();
  console.log('Query successful:', result);
  
  // 結果が空の場合の処理
  if (result.Items.length === 0) {
    console.log('No items found for the query');
    // 適切なレスポンスを返す
  }
  
} catch (error) {
  console.error('Error executing query:', error);
  
  // エラータイプによる分岐処理
  if (error.code === 'ProvisionedThroughputExceededException') {
    // スロットリングエラーの場合
    console.log('Rate limit exceeded, implementing backoff strategy');
    // 指数バックオフ再試行ロジックを実装
  } else if (error.code === 'ResourceNotFoundException') {
    // テーブルやインデックスが存在しない場合
    console.error('Table or index not found:', error.message);
  } else {
    // その他のエラー
    console.error('Unexpected error:', error);
  }
}
```

**補足説明：**
- **詳細なエラーハンドリング:**  
  エラーコードに基づいて適切な処理を行い、システムの安定性を高めます。
- **再試行ロジック:**  
  スロットリングなどの一時的なエラーに対して、指数バックオフなどの再試行戦略を実装します。
- **空の結果セット対応:**  
  クエリ結果が空の場合も適切に処理し、ユーザーエクスペリエンスを向上させます。

### 6.2 コスト最適化
* **ProjectionExpressionの活用:**  
  必要な属性のみを取得することで、読み込みコストやレスポンスサイズの最適化を図ります。
* **適切なキャパシティユニット設定:**  
  予想されるアクセス頻度に合わせたRead/Write容量の設定を行い、不要なコストを抑えます。
* **クエリ効率化:**  
  インデックスの適切な設計や、不要なスキャン操作の回避により、全体のパフォーマンスとコストのバランスを調整します。

### 6.3 コスト見積もり例

現実的なビジネスシナリオに基づいたコスト試算例です：

**想定条件：**
- ユーザー数: 10,000人
- 1ユーザーあたりの月間注文数: 平均5件
- 注文データサイズ: 約2KB/アイテム
- 月間アクティブユーザー率: 80%

**月間データ量：**
- 新規注文データ: 10,000 × 5 = 50,000アイテム/月
- 総格納データ量: 50,000 × 2KB = 100MB/月（累積）

**月間操作量：**
- 書き込み操作: 50,000 WCU（新規注文のみ）
- 読み取り操作:
  - 注文履歴取得: 8,000 × 10 = 80,000 RCU（アクティブユーザーが月10回履歴確認）
  - 管理操作: 約20,000 RCU（ステータス別検索など）
  - 合計: 約100,000 RCU/月

**コスト比較（米国東部リージョン想定）：**
- **オンデマンドモード：**
  - 書き込み: 50,000 × $1.25/百万 = 約$0.06
  - 読み取り: 100,000 × $0.25/百万 = 約$0.03
  - ストレージ: 100MB × $0.25/GB = 約$0.03
  - 月額合計: 約$0.12

- **プロビジョンドモード：**
  - 書き込み: 2 WCU（ピーク時の調整値） × $0.00065/時間 × 730時間 = 約$0.95
  - 読み取り: 5 RCU（ピーク時の調整値） × $0.00013/時間 × 730時間 = 約$0.47
  - ストレージ: 約$0.03
  - 月額合計: 約$1.45

**推奨：**
トラフィックの変動が大きい場合や、成長段階のサービスではオンデマンドモードが適しています。安定したトラフィックで予測可能なワークロードの場合は、プロビジョンドモードの方がコスト効率が良くなる可能性があります。

---

この設計パターンは基本的な注文管理システムを想定しており、ビジネス要件に応じて柔軟にカスタマイズできます。特に、事前にアクセスパターンを明確に定義することで、後の拡張やパフォーマンス最適化に大きく寄与します。
