-- モジュールとインポート
module Utils where

import Prelude
import Data.Array (head, tail, length, range, (..), (:))
import Data.Maybe (Maybe(..), fromMaybe)
import Data.String (split, Pattern(..), joinWith)
import Data.Foldable (foldl, foldr)
import Effect (Effect)
import Effect.Random (randomInt)

-- 1. モナドを使った連鎖処理
parseAndDouble :: String -> Maybe Int
parseAndDouble str = do
  num <- parseInt str  -- Maybe Int
  pure (num * 2)      -- Maybe Int

-- Eitherを使ったエラーハンドリング
data ParseError = InvalidNumber String | EmptyInput

parseNumber :: String -> Either ParseError Int
parseNumber "" = Left EmptyInput
parseNumber str = 
  case parseInt str of
    Nothing -> Left (InvalidNumber str)
    Just n -> Right n

-- 2. 状態を持つ計算（State Monad風）
type GameState = 
  { score :: Int
  , lives :: Int
  , level :: Int
  }

initialState :: GameState
initialState = { score: 0, lives: 3, level: 1 }

addScore :: Int -> GameState -> GameState
addScore points state = state { score = state.score + points }

loseLife :: GameState -> GameState  
loseLife state = state { lives = state.lives - 1 }

-- 3. 関数型でのリスト処理
-- クイックソート実装
quickSort :: Array Int -> Array Int
quickSort [] = []
quickSort [x] = [x]
quickSort arr = 
  case head arr of
    Nothing -> []
    Just pivot -> 
      case tail arr of
        Nothing -> [pivot]
        Just rest ->
          let smaller = filter (_ <= pivot) rest
              larger = filter (_ > pivot) rest
          in quickSort smaller <> [pivot] <> quickSort larger

-- 4. 関数の部分適用とカリー化
multiply :: Int -> Int -> Int
multiply x y = x * y

multiplyByTwo :: Int -> Int
multiplyByTwo = multiply 2

-- 5. 型安全なAPI設計
data User = User
  { id :: UserId
  , name :: String
  , email :: Email
  }

newtype UserId = UserId Int
newtype Email = Email String

-- スマートコンストラクタ
mkEmail :: String -> Maybe Email
mkEmail str 
  | contains (Pattern "@") str && length str > 3 = Just (Email str)
  | otherwise = Nothing

mkUserId :: Int -> Maybe UserId
mkUserId n
  | n > 0 = Just (UserId n)
  | otherwise = Nothing

-- 6. タグ付き共用体（Sum Types）
data APIResponse a
  = Loading
  | Success a
  | Error String

handleResponse :: forall a. APIResponse a -> String
handleResponse Loading = "読み込み中..."
handleResponse (Success _) = "成功しました"
handleResponse (Error msg) = "エラー: " <> msg

-- 7. 型レベルでの制約
class Serializable a where
  serialize :: a -> String
  deserialize :: String -> Maybe a

instance serializableInt :: Serializable Int where
  serialize = show
  deserialize = parseInt

instance serializableString :: Serializable String where
  serialize = identity
  deserialize = Just

-- 8. リーダーモナド風のパターン
type Config = 
  { apiUrl :: String
  , timeout :: Int
  , debug :: Boolean
  }

type AppM a = Config -> Effect a

runApp :: forall a. Config -> AppM a -> Effect a
runApp config app = app config

-- 設定を読み取る関数
getApiUrl :: AppM String
getApiUrl config = pure config.apiUrl

-- 9. レンズ風のデータアクセス
-- レコード更新のヘルパー
updateUserName :: String -> User -> User  
updateUserName newName (User user) = User (user { name = newName })

updateUserEmail :: Email -> User -> User
updateUserEmail newEmail (User user) = User (user { email = newEmail })

-- 10. 実践的な例：TODOアプリのデータ構造
data TodoStatus = Pending | Completed | Archived

derive instance eqTodoStatus :: Eq TodoStatus
derive instance showTodoStatus :: Show TodoStatus

type Todo = 
  { id :: Int
  , title :: String
  , description :: String
  , status :: TodoStatus
  , createdAt :: String
  }

type TodoList = Array Todo

-- TODO操作関数
addTodo :: Todo -> TodoList -> TodoList  
addTodo todo todos = todo : todos

completeTodo :: Int -> TodoList -> TodoList
completeTodo todoId = map \todo ->
  if todo.id == todoId 
    then todo { status = Completed }
    else todo

filterByStatus :: TodoStatus -> TodoList -> TodoList
filterByStatus status = filter \todo -> todo.status == status

-- 集計関数
countByStatus :: TodoStatus -> TodoList -> Int
countByStatus status todos = 
  length $ filterByStatus status todos

-- ランダムな数値生成
generateRandomScore :: Effect Int  
generateRandomScore = randomInt 1 100

-- 文字列処理ユーティリティ
slugify :: String -> String
slugify str = 
  str
    # toLower
    # split (Pattern " ")
    # joinWith "-"

-- パイプライン演算子の使用例  
processText :: String -> String
processText text = 
  text
    # trim
    # toLower  
    # split (Pattern " ")
    # filter (\word -> length word > 2)
    # joinWith " "
