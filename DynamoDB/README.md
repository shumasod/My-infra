以下は各項目の説明補足を加えたドキュメント例です。

---

# DynamoDBテーブル設計とクエリパターン解説

このドキュメントでは、注文管理システムを例に、DynamoDBのテーブル設計とクエリパターンについて解説します。各項目には、その役割や設計時の注意点、実装の際のポイントなどを補足しています。

---

## 1. テーブル基本設計

テーブル設計の基本となる部分です。注文管理システムのユースケースに合わせたキー設計やインデックス設定の基本構造を示します。

### 1.1 キー スキーマ

```javascript
{
  TableName: 'Orders',
  KeySchema: [
    { AttributeName: 'PK', KeyType: 'HASH' },  // パーティションキー
    { AttributeName: 'SK', KeyType: 'RANGE' }  // ソートキー
  ]
}
```

**補足説明：**
- **パーティションキー (PK)：**  
  データの分散や検索効率を決定する主要な識別子です。この例では、ユーザーごとにデータをまとめるために使用されます。
- **ソートキー (SK)：**  
  同じパーティション内でデータを時系列やその他の順序付け基準で整理するために利用します。ここでは注文日など、順序が重要な情報を扱うのに適しています。

### 1.2 インデックス設定

基本のテーブルに加え、効率的な検索や柔軟なクエリのためにインデックスを設計します。

* **プライマリインデックス：**
  - **PK (パーティションキー):** ユーザーID  
    ユーザーごとの注文情報のグループ化に使用。
  - **SK (ソートキー):** 注文日  
    注文日を基準に並べ替え、履歴の取得や期間指定検索を容易にします。

* **グローバルセカンダリインデックス (GSI1)：**
  - **GSI1PK:** 注文ステータス  
    注文の状態（例：COMPLETED, PENDINGなど）に基づく検索が可能となります。
  - **GSI1SK:** 注文日  
    ステータスごとの注文を、日付でソートすることで、期間指定のクエリにも対応できます。

**補足説明：**
- **インデックスの利点：**  
  インデックスを追加することで、主テーブルの設計に影響を与えずに多様な検索パターンを実現できます。特にアクセス頻度の高いクエリ（例：注文ステータス別の検索など）に対して、専用のインデックスを設けるとパフォーマンスが向上します。

---

## 2. データモデリング例

実際の注文アイテムのデータ構造例を示し、どのような属性を持たせるかを具体的に解説します。

### 2.1 注文アイテムの構造

```javascript
{
  PK: 'USER#123',           // ユーザーID
  SK: 'ORDER#2024-01-01',    // 注文日
  orderId: 'ORD-001',        // 注文固有ID
  userId: '123',             // ユーザーID（冗長性のために保持する場合も）
  orderDate: '2024-01-01',   // 注文日（検索・表示用）
  status: 'COMPLETED',       // 注文状態（例：COMPLETED, PENDINGなど）
  total: 5000,               // 注文合計金額
  items: [
    { productId: 'P1', quantity: 2, price: 1500 },
    { productId: 'P2', quantity: 1, price: 2000 }
  ],
  GSI1PK: 'ORDER#COMPLETED', // GSI用：注文状態を含むキー
  GSI1SK: '2024-01-01'       // GSI用：注文日（ソート用）
}
```

**補足説明：**
- **冗長性:**  
  主テーブルのキーと別に、検索に必要な属性（例：orderDateやstatus）を各項目としても保持することで、効率的なクエリが可能です。
- **items配列:**  
  複数の注文アイテムを含む場合は、ネストされたデータ構造を利用し、商品の詳細（productId、数量、単価）をまとめています。

---

## 3. 主要クエリパターン

具体的なクエリ例を示し、どのようにデータを取得するかを説明します。

### 3.1 ユーザーの注文履歴取得

```javascript
{
  TableName: 'Orders',
  KeyConditionExpression: 'PK = :userId',
  ExpressionAttributeValues: {
    ':userId': 'USER#123'
  }
}
```

**補足説明：**
- **ポイント:**  
  ユーザーIDをパーティションキーに設定することで、該当ユーザーのすべての注文履歴を一度に取得できます。ソートキーにより、注文日で並び替えが可能です。

### 3.2 期間指定での注文取得

```javascript
{
  TableName: 'Orders',
  KeyConditionExpression: 'PK = :userId AND SK BETWEEN :startDate AND :endDate',
  ExpressionAttributeValues: {
    ':userId': 'USER#123',
    ':startDate': 'ORDER#2024-01-01',
    ':endDate': 'ORDER#2024-12-31'
  }
}
```

**補足説明：**
- **期間指定検索:**  
  ソートキーを使い、特定期間内の注文情報を絞り込むためのクエリです。BETWEEN句を用いることで、開始日から終了日までの範囲検索を実現しています。

### 3.3 ステータス別注文取得（GSI使用）

```javascript
{
  TableName: 'Orders',
  IndexName: 'GSI1',
  KeyConditionExpression: 'GSI1PK = :status',
  ExpressionAttributeValues: {
    ':status': 'ORDER#COMPLETED'
  }
}
```

**補足説明：**
- **GSIの利用:**  
  プライマリキー以外の属性（この場合は注文状態）での検索が可能です。GSI1PKに基づいて、特定のステータスの注文情報を効率的に取得できます。

---

## 4. 設計のベストプラクティス

システム全体のパフォーマンスや拡張性を高めるための設計上の注意点や推奨事項です。

### 4.1 キー設計のポイント
* **主要識別子:**  
  パーティションキーにはデータの一意性を担保する主要な識別子を使用します。ユーザーIDや注文IDなどが適しています。
* **ソートキー:**  
  時系列データや範囲検索が必要な属性を設定することで、後続のクエリパフォーマンスが向上します。
* **GSI:**  
  頻繁な検索パターンに合わせ、必要な属性に対してグローバルセカンダリインデックスを設計します。

### 4.2 データモデリングの注意点
* **単一テーブルデザイン:**  
  関連するデータを1つのテーブルに格納することで、JOIN処理を回避し、パフォーマンスの最適化を図ります。
* **事前の検索パターン定義:**  
  どのようなクエリが頻繁に行われるかを前もって把握し、それに合わせた属性やインデックスの設計を行います。
* **明確な命名規則:**  
  属性名やインデックス名は、誰が見ても理解しやすいように一貫した命名規則を採用することが重要です。

---

## 5. 拡張検討ポイント

将来的な要件追加やシステム拡張を見据えた設計上の検討事項です。

### 5.1 追加可能な機能
* **製品カテゴリによる検索:**  
  新しいGSIを追加し、製品カテゴリをキーにした検索を可能にすることで、ユーザー体験を向上できます。
* **注文金額による範囲検索:**  
  注文合計金額を元にしたフィルタリング機能を追加することで、金額に応じたデータ抽出が可能になります。
* **配送ステータスの追跡:**  
  注文の配送状況を管理するフィールドを追加するなど、サービス向上のための拡張を検討します。

### 5.2 パフォーマンス最適化
* **ホットパーティションの回避:**  
  特定のパーティションにアクセスが集中しないよう、キー設計やデータ分散に注意する必要があります。
* **バッチ処理:**  
  一括更新や集計処理は、バッチ処理を活用して効率的に実施します。
* **スキャンオペレーションの最小化:**  
  クエリやインデックスを適切に設定し、必要最小限のデータ取得に留めることで、コストとパフォーマンスのバランスを図ります。

---

## 6. 実装時の注意点

実際にシステムを実装する際のエラーハンドリングやコスト最適化のポイントを解説します。

### 6.1 エラーハンドリング

```javascript
try {
  const result = await dynamodb.query(params).promise();
  console.log('Query successful:', result);
} catch (error) {
  console.error('Error executing query:', error);
}
```

**補足説明：**
- **例外処理:**  
  DynamoDBへのクエリ実行時に、予期せぬエラーが発生する可能性があるため、try-catch構文を使用してエラーを適切にハンドリングします。  
- **ログ出力:**  
  エラー内容をログに記録することで、後続のトラブルシューティングや監視に役立ちます。

### 6.2 コスト最適化
* **ProjectionExpressionの活用:**  
  必要な属性のみを取得することで、読み込みコストやレスポンスサイズの最適化を図ります。
* **適切なキャパシティユニット設定:**  
  予想されるアクセス頻度に合わせたRead/Write容量の設定を行い、不要なコストを抑えます。
* **クエリ効率化:**  
  インデックスの適切な設計や、不要なスキャン操作の回避により、全体のパフォーマンスとコストのバランスを調整します。

---

この設計パターンは基本的な注文管理システムを想定しており、ビジネス要件に応じて柔軟にカスタマイズできます。特に、事前にアクセスパターンを明確に定義することで、後の拡張やパフォーマンス最適化に大きく寄与します。
