

---

## **1. なぜDBで分散処理を行うのか**

* **性能向上（スケーラビリティ）**
  大量データや高トラフィックを複数ノードに分散して処理
* **可用性向上（フェイルオーバー）**
  ノード障害時も別ノードで継続稼働
* **地理的分散**
  複数リージョンでユーザに近い場所から低レイテンシ応答

---

## **2. 分散DBの基本構成**

* **シャーディング（Sharding）**

  * データをキー単位で分割し、複数ノードに配置
  * 例: ユーザIDの範囲ごとに異なるノードへ
* **レプリケーション（Replication）**

  * データを複製して複数ノードに保持
  * 主に可用性向上や読み込み分散に利用
* **マスタ/スレーブ構成**

  * 書き込みはマスタ、読み込みはスレーブで分散
* **マルチマスタ構成**

  * 複数ノードが書き込み可能（ただし整合性管理が難しい）

---

## **3. データ分割方法（シャーディング）**

1. **水平分割（Horizontal Partitioning）**

   * 行単位で分割
   * 例: ユーザID 1〜1,000,000 → shard1, 1,000,001〜 → shard2
2. **垂直分割（Vertical Partitioning）**

   * カラム単位で分割（大きなBLOBや履歴データを別DBへ）
3. **ハッシュ分割**

   * ハッシュ関数でシャードを決定 → データ分布が均等化しやすい
4. **レンジ分割**

   * 日付やID範囲でシャードを決定

---

## **4. 一貫性モデル（CAP定理）**

分散DBは**CAP定理**の制約を受けます。

* **C**（Consistency: 一貫性）
  全ノードで同じデータが見える
* **A**（Availability: 可用性）
  常に応答を返す
* **P**（Partition Tolerance: 分断耐性）
  ネットワーク分断時でも動作継続

⚠ 同時に3つは満たせず、設計上どれを優先するか選ぶ必要があります。

* MySQLレプリケーション: AP寄り（可用性重視、レプリ遅延あり）
* 分散トランザクション型DB: CP寄り（一貫性重視、可用性低下の可能性あり）

---

## **5. 分散トランザクション**

* **2PC（Two-Phase Commit）**

  * コーディネータが全ノードに「準備→確定」指示を出す
  * 高い一貫性だが遅延が大きい
* **Paxos / Raft**

  * 合意アルゴリズムで状態を同期
  * Google Spanner, Etcd, CockroachDBなどで利用

---

## **6. 分散クエリ**

* データが複数ノードにある場合、クエリ実行計画は**データ移動量を最小化**するように設計
* 分散JOINや分散集計はネットワーク負荷が大きいため注意
* 可能ならシャード内完結のクエリに設計（"locality"の確保）

---

## **7. 運用上の注意点**

* ノード障害時の**フェイルオーバー手順**（自動/手動）
* **再シャーディング**（データ量増加時の分割再配置）
* レプリ遅延の監視（読み取り一貫性問題）
* バックアップ・リストアのノード間整合性確保

---

## **8. MySQL / PostgreSQLでの代表例**

* **MySQL**

  * MySQL Group Replication / InnoDB Cluster（マルチマスタ）
  * ProxySQL + シャーディング
* **PostgreSQL**

  * Citus（シャーディング拡張）
  * pgpool-II（読み書き分離）
  * Bucardo / Slony-I（非同期レプリケーション）

---

これを図解にして「分散DBの地図」にすると、シャーディングとレプリケーション、CAP定理の関係が直感的に理解できます。
もしよければ、その図も作れます。
